-- TODO: query the hist table from the sample-0.01 db
with hist as (select c.ngramarr,c.epochstartmillis,CAST(c.cnt as float8)/CAST(v.totalcnt as float8) as prop
    from cnt_1hr1 c join volume_1hr1 v on c.epochstartmillis = v.epochstartmillis
        where cnt >= 5 and
		date >= 121030 and date <= 121107 and c.epochstartmillis < 1352286000000 ),
 curr as (select c.*,v.totalcnt,CAST(c.cnt as float8)/CAST(v.totalcnt as float8)  as prop
     from cnt_1hr1 c join volume_1hr1 v on c.epochstartmillis = v.epochstartmillis
         where cnt >= 5 and
		date in (121106,121107) and c.epochstartmillis >= (1352199600 * 1000::INT8) and c.epochstartmillis < (1352286000 * 1000::INT8) )
  select curr.ngramarr, curr.epochstartmillis, min(curr.cnt),
        (min(curr.prop) - avg(hist.prop))/stddev_pop(hist.prop) as stdprop, --min(curr.prop) * min(curr.totalcnt) as cnt, 
        (1352286000000 - max(hist.epochstartmillis)) / 3600000 as lastseenlag, (1352286000000 - min(hist.epochstartmillis))/3600000 as firstseenlag,
        ((min(curr.prop) - avg(hist.prop))/stddev_pop(hist.prop)) * (1 - ((1352286000000 - max(hist.epochstartmillis)) / (1352286000000 - min(hist.epochstartmillis)))) as laggedstdprop
            from hist join curr on curr.ngramarr = hist.ngramarr
                group by curr.ngramarr, curr.epochstartmillis 
having
-- This introduces a lot of stop words in the list, maybe becuase everything else gets pruned out.. the threshold can get lower and lower, but
-- then what's the point of having it.. actually, there was no point in all what I did the previous hour: avg(hist.prop) >= 0.0001 and 
count(*) >= 3 -- just to avoid the instability when stddev = 0 for things that appeared once.. we can always include them from another query (we should)
order by laggedstdprop desc limit 1000;